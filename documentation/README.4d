
================================================================
Technical Description of Four-Dimensional Visualization
================================================================

Viewing Space
=============

You are looking at the (i,j,k) subspace of pure quaternions.  The
vector i points to the right, j points up, and k points out of the
screen.

Inversion
=========

The parameter labeled 'inversion' in the example applications
represents the reciprocal of the point at infinity.

When inversion = 0 the effect is orthographic projection: the real
coordinate is simply stripped away.

When inversion = 1 the effect is stereographic projection: the unit
3-sphere is mapped conformally onto the whole subspace of pure
quaternions --- the space you see.

When inversion approaches infinity, the effect is to swap infinity and
the origin.

Mouse Control
=============

Mouse control starts off in "longitude/latitude mode".

The left button creates rotations which leave invariant the equatorial
(i,j,k) 2-sphere of latitude (the 2-sphere of unit pure quaternions) .

The right button creates rotations which leave invariant the (1,i,j)
2-sphere of longitude passing through the poles -1 and 1.  In the
full orthographic projection (inversion = 0), this invariant
longitudinal 2-sphere is projected to a circular disk lying in the
(i,j)-plane.  In the full stereographic projection (inversion = 1),
the (1,i,j) 2-sphere is sent to the whole (i,j)-plane.

In hopfviewer, starting from the home transform (press "r"), make some
rotations using only the right mouse button.  You will notice that the
inner bounding circle and the outer bounding circle always face the
same direction: points in the (i,j)-plane are constrained to stay in
the (i,j)-plane (because the (1,i,j)-sphere is invariant).

The other mouse mode is "Hopf mode".  Its actions are: left Hopf
rotation, right Hopf rotation, and right Hopf rotation with negated
angle, respectively, for the left, middle, and right buttons.  The
rotation planes are (1,u) and (1,u)-perp where u is a unit pure
representing the mouse drag direction in the (i,j)-plane.  The signs
of the rotation planes are +/+, -/+, and +/- respectively for each
button.

The following are roughly equivalent:

long-lat mode              Hopf mode
-------------              -----------
left button     <====>     left+middle buttons together
right button    <====>     left+right buttons together

The actual transformations are

long-lat mode
-------------
left button:     z |-----> p*z*conj(p)    latitudinal rotation
right button:    z |-----> p*z*p          longitudinal rotation

Hopf mode
---------
left button:     z |-----> p*z            left Hopf rotation
middle button:   z |-----> z*conj(p)      right Hopf rotation
right button:    z |-----> z*p            right Hopf rotation, neg angle

where p = exp(u*theta) with theta being a differential angle
proportional to the mouse velocity.  In the case of long-lat mode /
left button, u is rotated 90 degrees in the (i,j)-plane for a more
intuitive feel.

Ideally u would come from a three-dimensional input, a direction in
(i,j,k)-space.  Nonetheless, SO(4) is easily generated by these
actions with u constrained to the (i,j)-plane, in long-lat mode and in
Hopf mode.  A general u in (i,j,k) may be simulated using the
parenting feature described below.

Not yet mentioned is long-lat mode / middle button, which rotates the
(i,j)-plane by an angle proportional to the horizontal drag while
simultaneously rotating the (1,k)-plane by an angle proportional to
the vertical mouse drag.

The interesting aspect of Hopf mode is the commutation of the
left-button and right-button actions (as well as the left-button and
middle-button actions).

About Motions
=============

The button actions are tied to frames in a parenting relationship: the
left button is grandpa, the middle is pa, and the right is baby.  Thus
the "u" of an action can effectively point in any (i,j,k) direction by
using long-lat mode / left button after the action is performed.

For each mouse button, its action is tied to the frame of reference at
the moment the button was pushed.  Try the following experiment:
First notice that a right-button horizontal drag in long-lat mode
corresponds to a "horizontal" 4D motion: the "line" of rotation,
i.e. the degenerate plane of rotation, is the horizontal i-axis.
While keeping the right button held down, rotate the object 90 degrees
using the left mouse button.  Now right-button horizontal drags result
in motions pointing directly toward you, since the line of rotation
now points in that direction.

A note on "prolonged" mouse drags: A simple demonstration of the
non-commutativity of SO(3) is to drag the left button (long-lat mode)
in, say, a circular path.  When the mouse pointer returns to its
original position (where the drag started), the object contrariwise
does not return to _its_ original position.

Similarly in SO(4), although the left and right families Hopf
rotations commute with each other, neither family of Hopf rotations
commutes with itself when the mouse drag is curved.  Thus in order to
observe commutativity all drags must take place in a straight line.

